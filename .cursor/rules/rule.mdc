---
alwaysApply: true
---
# Development Rules Summary

## Overview

This document provides a concise summary of the mandatory development rules for the DAW project. For complete details, see [DAW_DEV_RULES.md](DAW_DEV_RULES.md).

**CRITICAL**: These rules are MANDATORY. Violations result in code rejection.

## Global Principles

### No Glitches, No Pops
- Audio must never emit pops/clicks due to our code
- Non-recoverable issues must mute or bypass gracefully
- Never explode user's monitors

### Real-Time First
- Audio correctness and timing > everything else
- No feature compromises real-time safety
- Performance budgets are hard limits

### Determinism & Reproducibility
- Same project + same inputs = same output
- No hidden randomness (unless seeded and stored)
- Cross-session and cross-machine consistency

### Cross-Platform Parity
- macOS + Windows (and Linux) must have feature parity
- No OS-specific "secret" features
- Consistent UX across platforms

### Professional UX
- Fast, predictable, undoable, discoverable
- "Feels like a toy" = bug
- "Feels like a pro workstation" = target

## JUCE/C++ Core Standards

### Memory Management (CRITICAL)
- **NO** raw `new`/`delete`/`malloc`/`free`
- Use RAII and smart pointers (`std::unique_ptr`, `std::shared_ptr`)
- Use JUCE containers (`OwnedArray`, `Array`)
- Enforcement: `-Werror`, clang-tidy, code review

### Thread Safety (CRITICAL)
- Audio thread must NEVER block or allocate
- No locks, waits, or heap operations in `processBlock()`
- Use atomics and lock-free structures
- Example: `std::atomic<float> gain { 1.0f };`

### Component Lifecycle
- Components belong to owners
- No manual `delete` while in tree
- Use member variables or smart pointers

### C++ Standards
- C++17 minimum, C++20 preferred
- Use `auto`, `constexpr`, `noexcept`, `[[nodiscard]]`
- Structured bindings, `std::optional`, `std::variant` where appropriate

### Exception Handling
- Audio thread: logically `noexcept`, no throwing
- UI/IO threads: handle exceptions, show user-friendly messages
- Graceful fallbacks on errors

## Audio Processing Rules

### Real-Time Thread Safety (CRITICAL)
- `processBlock()` must finish within time budget
- **NO** heap allocation
- **NO** locks (`std::lock_guard`, `CriticalSection`, etc.)
- **NO** file/network/console I/O
- **NO** logging to disk (only lock-free ring buffer if needed)

### Sample Rate & Buffer Size
- Fully dynamic, no hardcoded values
- No assumptions about 44.1/48k or 512 samples
- Handle any sample rate and buffer size

### Latency & Delay Compensation
- Report correct latency
- Keep latency deterministic
- No random or time-varying latency
- Automation accounts for latency

### DSP Stability
- Numerically stable, denormal-safe, clamped
- Handle NaN/Inf
- Avoid catastrophic cancellation
- Document edge cases

### Plugin Formats
- Use JUCE abstractions
- No VST/AU/AAX-specific hacks in core DSP
- Must pass validation tools (pluginval)
- Identical behavior: offline render vs live, different buffer sizes

### Automation & Modulation
- Sample-accurate where possible
- Always artifact-free
- Smooth fast changes (no zipper noise)
- Automation jumps must not click

## AI Integration Standards

### No AI on Audio Thread (CRITICAL)
- AI runs on background workers only
- Audio thread only reads results via atomics/lock-free queues
- Hard rule: `processBlock()` call stack must never call AI

### Model Lifecycle
- Models loaded on background threads
- Progress and failure surfaced to UI
- Large allocations done once and reused
- Clear versioning and compatibility

### Inference Threading
- Dedicated inference worker pool
- Bounded queues (e.g., 4 items max)
- Backpressure: drop oldest or decline new requests
- Never piggyback on UI thread

### Failure & Fallback
- On AI failure: audio continues with non-AI fallback
- Non-intrusive warning in UI (status bar)
- No modal that blocks playback

### Performance
- Track average and P95 inference time
- Targets: P95 < 50 ms (clip-level), < 200 ms (track-level)
- If exceeded: degrade quality or apply approximation

## UI/UX Professional Standards

### LookAndFeel & Design System
- Single, centralized design system
- One global `CustomLookAndFeel`
- `DesignSystem` namespace: Colors, Typography, Spacing, Radii, Shadows
- **NO** magic numbers in paint/layout

### Layout & Responsiveness
- Fully resizable, dockable, remembers layout
- Main areas: Transport, Arrangement, Mixer, Browser, Inspector
- Split views, collapsible panels, saved workspaces
- No fixed pixel layouts

### Input Model & Shortcuts
- Fully usable via keyboard + mouse
- Unified input manager: every command has ID, shortcut, menu entry
- Rebindable shortcuts with clear UI
- Common: Space (Play/Stop), Ctrl/Cmd+Z/Y (Undo/Redo), Ctrl/Cmd+S (Save)

### Accessibility
- Keyboard focus traversal works everywhere
- High-contrast theme supported
- Font sizes scalable
- Accessible names/descriptions for controls
- Screen-reader safe state changes

### UI Performance (60fps Target)
- Dirty-rect repainting: `repaint(region)` not `repaint()`
- Cache static visuals (Image caches, Path precomputation)
- Heavy layout only on resize/structural changes
- Animations use `ComponentAnimator` or time-based

### DAW-Specific UX
- **Timeline**: Drag to create/move/trim clips, snap to grid, smooth zoom, multi-selection
- **Mixer**: Consistent channel strips, large faders/meters, clear track/bus/master differentiation
- **Editors**: Multi-tool model, velocity/pitch/timing editing, crisp visuals under zoom
- **Undo/Redo**: Every operation undoable, semantic undo steps

### Visual Feedback
- Hover, active/pressed, disabled, error states for all interactive elements
- Meters reflect engine state (XRuns/overloads)
- CPU/DSP usage in clear meter + numeric readout

## Code Quality & Architecture

### SOLID Principles
- No "god classes" mixing audio engine + UI + IO
- Single responsibility, clear interfaces

### Layered Architecture
- Clear layers: Core → Audio Engine → AI & Analysis → Project Model → UI → Integration
- Lower layers never depend on higher layers
- UI only talks to engine/model via well-defined interfaces

### Module & Namespace Layout
- Structure: `src/core/`, `src/audio/engine/`, `src/audio/dsp/`, `src/project/`, `src/ui/`, `src/ai/`
- Namespaces: `daw::core`, `daw::audio::engine`, `daw::ui::views`, etc.
- Global namespace: minimal (entry points only)

### Documentation
- All public classes + methods: Doxygen-style comments
- Complex components: "How to use" section
- Audio engine & project model: separate design docs

### Testing
- No merging critical engine code without tests
- Audio: unit tests, regression tests, real-time safety tests
- Project model: save/load roundtrip, undo/redo tests
- Coverage: Audio engine + project model: 80%+ required

## Performance Requirements

### Audio Thread Budget (CRITICAL)
- 48kHz, 128 samples: < 1.5 ms per buffer
- 48kHz, 256 samples: < 3.0 ms per buffer
- 96kHz, 128 samples: < 0.8 ms per buffer
- No single plugin/node > 30% of budget at default settings

### Multi-Core & Graph Scheduling
- Audio graph designed for parallel execution
- Identify independent subgraphs
- Avoid unnecessary serialization
- No false data dependencies

### UI Performance Budget
- Paint operations: no dynamic allocations, no cache thrash
- Timeline and mixer: responsive at 60fps during zoom/scroll

### AI Performance Budget
- Real-time assist: < 50 ms perceived delay
- Clip analysis: < few seconds for typical song
- Background jobs never block playback/UI/save/load

### Profiling & Regression
- Profiling presets for stress testing
- Regular benchmarks on reference machines
- Detect regressions: > 10% performance drop = review required

## Security & Privacy

### Plugin Isolation
- Host third-party plugins with extreme suspicion
- Validate formats, sandboxing where possible
- Plugin crash must not crash DAW
- Best effort recovery, project autosave before crash

### File System & Network
- Project files: clear structured format with versioning
- No arbitrary code execution from project content
- Cloud/collaboration: HTTPS only, credentials in OS keychain
- No secrets in logs

### Telemetry & Analytics
- Opt-in and transparent
- No audio content uploaded without explicit consent
- Users can disable completely and permanently

### Crash Handling
- Crash handler: captures stack trace, offers to save report
- Project autosave: configurable interval, cleaned up on successful close

## Build & Deployment

### Toolchain
- Single CMake project: standalone app, VST3, AU (AAX if licensed)
- Compiler warnings: `-Wall -Wextra -Wpedantic` (or MSVC equivalents)
- Treat warnings as errors

### Target Matrix
- Windows 10/11 x64, macOS (current major -1 and newer, Intel + Apple Silicon)
- CI must: build all formats on all platforms, run tests + plugin validation

### Packaging
- Separate builds: Release (optimized), Debug (full symbols)
- Installer/bundle: include required runtimes, don't pollute system

## Enforcement & Tooling

### Static Analysis & Formatting
- clang-tidy with real-time rules
- clang-format for code style
- All checks run in CI and locally via pre-commit hooks

### Mandatory Code Review Checklist
Before merge, confirm:
- No raw owning pointers
- No locks/allocations in audio thread
- C++17+ features used sensibly
- Public APIs documented
- Tests written and passing, coverage OK
- UI uses design system (no magic values)
- Layout responsive and non-janky
- Thread safety sound
- Error paths and fallbacks implemented
- No secrets or file paths hardcoded
- No platform-specific hacks without guards/comments

### AI Dev / Assistant Guardrails
- Never change real-time audio code to add logs/allocations/locks
- Prefer small, local changes over massive rewrites
- For new features: update design system (if UI), add tests (if engine/model), update docs (if public API)
- If in doubt: choose stability over "cool feature"

## Quick Reference

### Audio Thread: DO
- Use atomics for parameters
- Pre-allocate buffers
- Use lock-free structures
- Keep processing deterministic

### Audio Thread: DON'T
- Allocate memory
- Use locks
- Block or wait
- Call AI or file I/O
- Throw exceptions

### UI Thread: DO
- Use design system tokens
- Cache resources
- Dirty-rect repainting
- Handle exceptions gracefully

### UI Thread: DON'T
- Block audio thread
- Allocate in `paint()`
- Use magic numbers
- Create platform-specific hacks

## Enforcement

- **CI**: Automated checks (lint, tidy, tests, pluginval)
- **Code Review**: Mandatory checklist verification
- **Static Analysis**: Real-time rules enforcement
- **Coverage**: Minimum thresholds enforced

**Remember**: These rules are not suggestions. They are mandatory requirements for production code.

